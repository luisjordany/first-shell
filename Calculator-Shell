  /*========================================================================================================================================*/ 
   /*edicion para calculadora
   *En este punto se lee todo el codigo que genera el 
   *SHELL  de la calculadora*/
   
   /*uint8_t, uint8_t, uint8_t cuenta la asignacion de memoria en bytes*/

   /*EAX es un resgistro de acumulacion extendido. Almacena el valor de retorno de una 
    *funcion y lo utiliza como contenedor para operaciones matematicas sencillas*/
   //estructura inb y outb
   static inline uint8_t inb(uint16_t port) //inicia funcion que conectara con el driver del teclado
   {
       uint8_t ret; //crea la variable de respuesta
       asm volatile ( "inb %1, %0"   //asignacion binaria de encendido y apagado del puerto
                      : "=a"(ret)   //asigna la respuesta a la variable ret
                      : "Nd"(port) ); //indicacion de las restricciones N(8-bit enteros no definidos, para instruciones de salida y entrada) y d(registros) para el dato obtenido por port
       return ret;  //devulve el estado generado por la instruccion =a
   }
   /*la combinacion Nd genera la posibilidad de administrar espacios para ahorrar recursos*/
   
   static inline void outb(uint16_t port, uint8_t val)
   {
       asm volatile ( "outb %0, %1" : : "a"(val), "Nd"(port) );
   }

   //otras funciones
   static inline uint32_t farpeekl(uint16_t sel, void* off)
   {
       uint32_t ret;
       asm ( "push %%fs\n\t"
             "mov  %1, %%fs\n\t"
             "mov  %%fs:(%2), %0\n\t"
             "pop  %%fs"
             : "=r"(ret) : "g"(sel), "r"(off) );
       return ret;
   }

   static inline void farpokeb(uint16_t sel, void* off, uint8_t v)
   {
       asm ( "push %%fs\n\t"
             "mov  %0, %%fs\n\t"
             "movb %2, %%fs:(%1)\n\t"
             "pop %%fs"
             : : "g"(sel), "r"(off), "r"(v) );
       /* TODO: Should "memory" be in the clobber list here? */
   }

   static inline bool are_interrupts_enabled()
   {
       unsigned long flags;
       asm volatile ( "pushf\n\t"
                      "pop %0"
                      : "=g"(flags) );
       return flags & (1 << 9);
   }
   
   //asignacion de teclado 
   /*ATENCION
    * cuando detecta un numero lo acumula en un vector de caracteres, cuando ve un simbolo diferente, 
    * pasa los digitos guardados a un valor entero y vacia el vector, el valor entero se guarda en una
    * variable a y el siguiente valor en variable b*/

   void getScancode() {
        //variable que asigna el los valores obtenidos por inb()
        char c=inb(0x60); //0x64
        char numchar;
        bool enter = false;
        do {       //no te detengas!! realiza esta actividad...
            if(inb(0x60)!=c) {  //si no encuentra un valor 0
                c=inb(0x60);    //reinicio a cero
                if(c>0){        //si detecto un valor valido
                    switch(c){  //segun el valor encontrado
                        case 0x02 : numchar = '1';  
                        terminal_putchar(numchar);                    
                        break;
                        case 0x03 : numchar = '2'; 
                        terminal_putchar(numchar);
                        break;
                        case 0x04 : numchar = '3'; 
                        terminal_putchar(numchar);
                        break;
                        case 0x05 : numchar = '4'; 
                        terminal_putchar(numchar);
                        break;
                        case 0x06 : numchar = '5'; 
                        terminal_putchar(numchar);
                        break;
                        case 0x07 : numchar = '6'; 
                        terminal_putchar(numchar);
                        break;
                        case 0x08 : numchar = '7'; 
                        terminal_putchar(numchar);
                        break;
                        case 0x09 : numchar = '8'; 
                        terminal_putchar(numchar);
                        break;
                        case 0x0A : numchar = '9'; 
                        terminal_putchar(numchar);
                        break;
                        case 0x0B : numchar = '0'; 
                        terminal_putchar(numchar);
                        break;
                        case 0x1F : numchar = 's';      //suma
                        terminal_putchar(numchar);
                        break;
                        case 0x13 : numchar = 'r';      //resta
                        terminal_putchar(numchar);
                        break;
                        case 0x32 : numchar = 'm';      //multiplica
                        terminal_putchar(numchar);
                        break;
                        case 0x20 : numchar = 'd';      //divide
                        terminal_putchar(numchar);
                        break;
                        case 0x39 : numchar = '_'; //ESPACE guarda los valores a en otra variable y se alista para valores b
                        case 0x1C : enter = true;
                        numchar = 0;
                        break;
                    }
                }
            }
        } while(enter != true);  //has esta actividad al menos UNA VEZ hasta que se presione ENTER
    }   

       //menu
   void menu(){
    getScancode();
   }

    //Salto de linea
    void salto_linea(int row){
        terminal_row = terminal_row + row;
    }
   
  /*=========================================================================================================================================*/ 
   
